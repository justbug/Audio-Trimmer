# Repository Guidelines

## Architecture & Module Organization
The codebase follows SwiftUI best practices backed by The Composable Architecture (TCA) 1.23.0. Each feature module lives under `App/Sources/App/Features/<FeatureName>/` and is described by a single `@Reducer`-annotated type defining its `@ObservableState`, `Action`, and `Body`. Views bind to a `StoreOf<Feature>` and keep side effects out of SwiftUI code. Compose features through `Scope` in parent reducers rather than sharing mutable state, and surface dependencies through `DependencyValues` and `DependencyClient`s. Assets specific to the iOS wrapper stay in `Audio Trimmer/Assets.xcassets`, while cross-platform logic remains in the Swift package so both the SPM tests and the Xcode app can reuse it. Expose reusable feature reducers and helper modules with `public` access where needed.

## Build, Test, and Development Commands
Use the Swift Package Manager for routine builds: `swift build --package-path App` compiles the package, and `swift test --package-path App` runs all unit tests. To iterate on the iOS shell, open the Xcode project with `open "Audio Trimmer.xcodeproj"` and run the `Audio Trimmer` scheme. When validating previews or UI-only updates, prefer running `xcodebuild -project "Audio Trimmer.xcodeproj" -scheme "Audio Trimmer" -destination 'platform=iOS Simulator,name=iPhone 15' build`. Keep packages up to date with TCA 1.23.0 to ensure reducer macros, navigation helpers, and dependency management stay in sync with the documented APIs.

## SwiftUI & TCA Conventions
Follow Swift API design guidelines: PascalCase for types, camelCase for functions and properties, four-space indentation, and a ~120 character soft limit per line. In SwiftUI, favor modifiers over nested containers, use `@Bindable` properties generated by `@ObservableState`, and let views derive data through `Store` scoping rather than local state. Avoid keeping business logic in viewsâ€”instead trigger actions via `ViewStore.send` or bindings. Use `NavigationStackStore`, `IfLetStore`, and `SwitchStore` to coordinate navigation and conditional flows. Prefer `Effect.run` or `Reducers` composed with `withDependencies` for side effects while keeping them cancelable or debounced when user interactions make multiple requests.

## Testing Guidelines
Leverage the Swift `Testing` package alongside TCA's `TestStore` to validate reducer behavior. Structure tests per feature, exercising state mutations, effect scheduling, and dependency overrides via `withDependencies`. Name tests for the behavior under test (e.g., `@Test func trimsSilence_onExport()`), and rely on `#expect` assertions for clarity. Keep fixtures in `App/Tests/Resources/` when scenario data is required. Run `swift test --package-path App` before raising a PR, and document any intentionally skipped cases, timing adjustments, or dependency overrides in the PR description.

## Commit & Pull Request Guidelines
Continue using Conventional Commits (e.g., `feat: add waveform trimming reducer`). PRs should describe the problem, summarize the solution, and include simulator screenshots or screen recordings for UI updates. Always list the exact verification commands (e.g., `swift test --package-path App`). Link related issues and ensure reviewers can reproduce results using the build and test commands noted above.
